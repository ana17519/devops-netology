**Домашнее задание к занятию "6.6. Troubleshooting"**

**Задача 1**

**Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.**

**Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.**

**Вы как инженер поддержки решили произвести данную операцию:**

* напишите список операций, которые вы будете производить для остановки запроса пользователя

1) можно посмотреть список информацию об активных и/или бездействующих операциях, а также о неактивных сеансах, 
удерживающих блокировки в рамках транзакции командой $currentOp

db.currentOp({"secs_running":{$gte: 180}}) - опеции которые длятся 3 минуты

2) после нахождения нужного запроса, можно завершить его командой: db.killOp(opid)

* предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Для того, чтобы не попадать в ситуацию с зависающими запросами можно использовать метод maxTimeMS(), 
который устанавливает ограничение по времени для операции. 
Когда операция достигает указанного значения, MongoDB прерывает операцию.

**Задача 2**

**Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.**

**Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная 
и увеличивается пропорционально количеству реплик сервиса.**

**При масштабировании сервиса до N реплик вы увидели, что:**

* сначала рост отношения записанных значений к истекшим
* Redis блокирует операции записи

**Как вы думаете, в чем может быть проблема?**

Рост новых пар key-value по отношению к тем, которые должны быть очищены говорит о том, что растет размер хранилища, 
а значит ресурс памяти заканчивается, т.е. система испытывает нехватку памяти, так как запущенные процессы требуют 
больше физической памяти, чем доступно.

Блокировка на запись говорит о том, то выделенная память закончилась.

**Задача 3**

**Вы подняли базу данных MySQL для использования в гис-системе. 
При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:**
`
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '`

**Как вы думаете, почему это начало происходить и как локализовать проблему?**

Можно получить эти ошибки, если на сервер отправляется неверный или слишком большой запрос. 
Если mysqld получает пакет, который слишком велик или не соответствует порядку, он предполагает, 
что что-то пошло не так с клиентом, и закрывает соединение. 

**Какие пути решения данной проблемы вы можете предложить?**

Если нужны большие запросы (например, если вы работаете с большими BLOB столбцами), 
можно увеличить лимит запросов, установив max_allowed_packet переменную сервера, которая 
по умолчанию имеет значение 64 МБ. Также может потребоваться увеличить максимальный размер пакета на стороне клиента. 

Решение этой проблемы состоит в том, чтобы либо выполнить a mysql_ping() на соединении, если прошло много времени 
с момента последнего запроса (это то, что делает Connector/ODBC), либо установить wait_timeout на сервере mysqld 
такое высокое значение, которое на практике никогда не истекает.

<!--https://dev.mysql.com/doc/refman/8.0/en/gone-away.html-->

**Задача 4**

**Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает 
с большим объемом данных лучше, чем MySQL.**

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

****postmaster invoked oom-killer****

**Как вы думаете, что происходит?**

Обычно процесс или приложение запрашивают у ОС память, а сами используют ее не полностью. 
Если ОС будет выдавать память всем, кто ее просит, но не планирует использовать, очень скоро память закончится, 
и система откажет. Чтобы этого избежать, ОС резервирует память за процессом, но фактически не выдает ее. 
Память выделяется, только когда процесс действительно собирается ее использовать. Случается, что у ОС нет свободной памяти, 
но она закрепляет память за процессом, и когда процессу она нужна, ОС выделяет ее, если может. Минус в том, что иногда 
ОС резервирует память, но в нужный момент свободной памяти нет, и происходит сбой системы. OOM играет важную роль в этом 
сценарии и завершает процессы, чтобы уберечь ядро от паники. Когда принудительно завершается процесс PostgreSQL, 
в логе появляется подобного рода сообщение.

**Как бы вы решили данную проблему?**

Чтобы не приходилось использовать OOM-Killer для завершения PostgreSQL, можно установить 
для vm.overcommit_memory (параметр ядра в линуксе) значение 2. Это не гарантирует, что OOM-Killer не придется вмешиваться, но снизит 
вероятность принудительного завершения процесса PostgreSQL.

Если нужен именно этот объем данных, то можно попробовать выгружать не все данные целиком, 
а пачками (batch) меньшего размера.
