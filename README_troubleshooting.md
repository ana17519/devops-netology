**Домашнее задание к занятию "6.6. Troubleshooting"**

**Задача 1**

**Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.**

**Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.**

**Вы как инженер поддержки решили произвести данную операцию:**

* напишите список операций, которые вы будете производить для остановки запроса пользователя

1) можно посмотреть список информацию об активных и/или бездействующих операциях, а также о неактивных сеансах, 
удерживающих блокировки в рамках транзакции командой $currentOp

db.currentOp({"secs_running":{$gte: 180}}) - операции которые длятся 3 минуты

2) после нахождения нужного запроса, можно завершить его командой: db.killOp(opid)

* предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Для того, чтобы не попадать в ситуацию с зависающими запросами можно использовать метод maxTimeMS(), 
который устанавливает ограничение по времени для операции. 
Когда операция достигает указанного значения, MongoDB прерывает операцию.

**Задача 2**

**Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.**

**Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная 
и увеличивается пропорционально количеству реплик сервиса.**

**При масштабировании сервиса до N реплик вы увидели, что:**

* сначала рост отношения записанных значений к истекшим
* Redis блокирует операции записи

**Как вы думаете, в чем может быть проблема?**

Все зависит от объема данных, если в реплике данных много, то нагрузится сеть и в этот момент REDIS может блокировать операции записи.

REDIS может блокировать операции когда у него заканчивается память и когда он удаляет ключи с истекшим сроком.
Redis ключи не удаляет сам по себе ничего пока у него есть память, когда памяти перестанет хватать, он запустит механизм,
который начнет удалять ключи по определенному алгоритму.
Redis удаляет ключи двумя способами:

* исключает ключ, когда он запрашивается командой, но обнаруживается, что срок его действия уже истек.
* выводит несколько ключей каждые 100 миллисекунд.

Активное истечение срока действия разработано как адаптивное. Цикл истечения срока действия запускается каждые 100 миллисекунд 
(10 раз в секунду) и выполняет следующие действия:

Выбирает ключи ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP, убирая все ключи, срок действия которых уже истек.
Если более 25% ключей были найдены просроченными, то следует повторить операцию.

**Задача 3**

**Вы подняли базу данных MySQL для использования в гис-системе. 
При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:**

`
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '`

**Как вы думаете, почему это начало происходить и как локализовать проблему?**

Можно получить эти ошибки, если на сервер отправляется неверный или слишком большой запрос. 
Если mysqld получает пакет, который слишком велик или не соответствует порядку, он предполагает, 
что что-то пошло не так с клиентом, и закрывает соединение. 

**Какие пути решения данной проблемы вы можете предложить?**

Если нужны большие запросы (например, работа с большими BLOB столбцами), 
можно увеличить лимит запросов, установив max_allowed_packet переменную сервера, которая 
по умолчанию имеет значение 64 МБ. Также может потребоваться увеличить максимальный размер пакета на стороне клиента.

<!--https://dev.mysql.com/doc/refman/8.0/en/gone-away.html-->

**Задача 4**

**Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает 
с большим объемом данных лучше, чем MySQL.**

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

****postmaster invoked oom-killer****

**Как вы думаете, что происходит?**

Out-Of-Memory Killer — это процесс, который завершает приложение, чтобы спасти ядро от сбоя.

Обычно процесс или приложение запрашивают у ОС память, а сами используют ее не полностью. 
Если ОС будет выдавать память всем, кто ее просит, но не планирует использовать, очень скоро память закончится, 
и система откажет. 

Чтобы этого избежать, ОС резервирует память за процессом, но фактически не выдает ее. 
Память выделяется, только когда процесс действительно собирается ее использовать. Случается, что у ОС нет свободной памяти, 
но она закрепляет память за процессом, и когда процессу она нужна, ОС выделяет ее, если может. Минус в том, что иногда 
ОС резервирует память, но в нужный момент свободной памяти нет, и происходит сбой системы. 

**Как бы вы решили данную проблему?**

Как временное решение можно увеличить ресурсы в конфиге, и после этого в мониторинге смотреть, что происходит в момент утечек.

В лекции (с момента 2:20:34) упоминается process-exporter, он в частности может показать, какой процесс сколько памяти потреблял.
Если в какой-то момент виден взлет графиков, нужно посмотреть, что в этот момент происходит с сетевым траффиком, с дисками, очередями и тд





